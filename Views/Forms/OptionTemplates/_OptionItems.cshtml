@using FormReporting.Models.ViewModels.Components
@using FormReporting.Extensions
@model FormReporting.Models.ViewModels.Forms.OptionTemplateEditViewModel

@{
    // Configure EditableTable for option items
    var itemsTable = new EditableTableConfig
    {
        TableId = "option-items-table",
        ItemIndexPropertyName = "Items",
        AllowMultiSelect = true,
        AllowSorting = false,
        ShowRowNumbers = true,
        EmptyMessage = "No options added yet. Click 'Add Option' to start.",
        InitialRowCount = Model.Items?.Count ?? 0,
        Buttons = new EditableTableButtons
        {
            AddButtonText = "Add Option",
            AddButtonIcon = "ri-add-line",
            ClearAllButtonText = "Clear All",
            ClearAllButtonIcon = "ri-delete-bin-line",
            ShowAddButton = true,
            ShowClearAllButton = true,
            ShowRemoveButton = true,
            ShowDeleteSelectedButton = true
        },
        Columns = new List<EditableTableColumn>
        {
            new EditableTableColumn
            {
                PropertyName = "OptionLabel",
                Header = "Option Label",
                ColumnType = EditableColumnType.Text,
                IsRequired = true,
                Placeholder = "e.g., Very Satisfied",
                Width = "",
                DisplayOrder = 1
            },
            new EditableTableColumn
            {
                PropertyName = "OptionValue",
                Header = "Option Value",
                ColumnType = EditableColumnType.Text,
                IsRequired = true,
                Placeholder = "e.g., very_satisfied",
                Width = "",
                DisplayOrder = 2
            },
            
            new EditableTableColumn
            {
                PropertyName = "ScoreValue",
                Header = "Score",
                ColumnType = EditableColumnType.Decimal,
                Width = "",
                Step = 0.01m,
                Placeholder = "0.00",
                DisplayOrder = 3,
                ConditionalDisplay = "HasScoring"
            },
            new EditableTableColumn
            {
                PropertyName = "ScoreWeight",
                Header = "Weight",
                ColumnType = EditableColumnType.Decimal,
                Width = "",
                Step = 0.01m,
                DefaultValue = 1.0m,
                Placeholder = "1.0",
                DisplayOrder = 4,
                ConditionalDisplay = "HasScoring"
            },
           
            new EditableTableColumn
            {
                PropertyName = "IsDefault",
                Header = "Default",
                ColumnType = EditableColumnType.Checkbox,
                Width = "",
                DisplayOrder = 5
            }
        }
    }.BuildEditableTable();
}

<div class="alert alert-info mb-3">
    <i class="ri-information-line me-2"></i>
    <strong>Add Options:</strong> Click "Add Option" to create new options. Each option needs a label (display text) and value (stored data). 
    Enable scoring in Step 1 to add score values to options.
</div>

@{
    // Pass existing items data to the partial
    ViewData["ExistingItems"] = Model.Items;
}

<partial name="~/Views/Shared/Components/DataTable/_EditableTable.cshtml" model="itemsTable" />

@* Add hidden DisplayOrder inputs for existing items *@
@if (Model.Items != null && Model.Items.Any())
{
    @for (int i = 0; i < Model.Items.Count; i++)
    {
        <input type="hidden" name="Items[@i].DisplayOrder" value="@Model.Items[i].DisplayOrder" />
        <input type="hidden" name="Items[@i].TemplateItemId" value="@Model.Items[i].TemplateItemId" />
    }
}

<div class="alert alert-warning mt-3" id="no-items-warning" style="display: none;">
    <i class="ri-alert-line me-2"></i>
    <strong>Warning:</strong> You must add at least one option before saving the template.
</div>

<script>
    (function() {
        const tableId = 'option-items-table';
        const tbody = document.getElementById(tableId + '-tbody');
        
        // Auto-generate option values from option labels and update display orders
        function attachAutoGenerationListeners() {
            const optionLabelInputs = tbody.querySelectorAll('input[name*="OptionLabel"]');
            
            optionLabelInputs.forEach(function(labelInput) {
                const row = labelInput.closest('tr');
                const valueInput = row.querySelector('input[name*="OptionValue"]');
                
                if (valueInput) {
                    labelInput.addEventListener('input', function() {
                        // Only auto-generate if value is empty or was auto-generated
                        if (!valueInput.value || valueInput.dataset.autoGenerated === 'true') {
                            const generatedValue = this.value
                                .toLowerCase()
                                .replace(/[^a-z0-9\s]/g, '') // Remove special chars except spaces
                                .replace(/\s+/g, '_') // Replace spaces with underscores
                                .substring(0, 50); // Limit length
                            
                            valueInput.value = generatedValue;
                            valueInput.dataset.autoGenerated = 'true';
                        }
                    });
                    
                    // Mark manual edits to option value
                    valueInput.addEventListener('input', function() {
                        if (this.dataset.autoGenerated === 'true') {
                            this.dataset.autoGenerated = 'false';
                        }
                    });
                }
            });
            
            // Update display orders for all rows
            updateDisplayOrders();
        }
        
        // Auto-calculate DisplayOrder based on row position (1-based, not 0-based)
        function updateDisplayOrders() {
            if (!tbody) return;
            
            const rows = tbody.querySelectorAll('tr:not(#' + tableId + '-no-items-row)');
            
            // For existing items, preserve their DisplayOrder if they have one
            // For new items, assign sequential DisplayOrder values
            let nextDisplayOrder = 1;
            
            // First pass: find the highest existing DisplayOrder
            rows.forEach(function(row) {
                const existingDisplayOrderInput = row.querySelector('input[name*="DisplayOrder"]');
                if (existingDisplayOrderInput && existingDisplayOrderInput.value) {
                    const existingOrder = parseInt(existingDisplayOrderInput.value);
                    if (existingOrder >= nextDisplayOrder) {
                        nextDisplayOrder = existingOrder + 1;
                    }
                }
            });
            
            // Second pass: assign DisplayOrder to all rows sequentially
            rows.forEach(function(row, index) {
                // Find or create hidden DisplayOrder input
                let displayOrderInput = row.querySelector('input[name*="DisplayOrder"]');
                if (!displayOrderInput) {
                    displayOrderInput = document.createElement('input');
                    displayOrderInput.type = 'hidden';
                    displayOrderInput.name = row.querySelector('input').name.replace(/\.[^.]+$/, '.DisplayOrder');
                    row.appendChild(displayOrderInput);
                }
                
                // Always assign sequential DisplayOrder (1, 2, 3...) based on current row position
                displayOrderInput.value = index + 1;
            });
        }
        
        // Initial attachment
        if (tbody) {
            attachAutoGenerationListeners();
            
            // Re-attach listeners when new rows are added or removed
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                        attachAutoGenerationListeners();
                    }
                });
            });
            
            observer.observe(tbody, { childList: true });
        }
        
        // Form validation before submit
        const createForm = document.getElementById('createTemplateWizard');
        const editForm = document.getElementById('editTemplateWizard');
        
        function validateForm(e) {
            const itemCount = tbody ? tbody.querySelectorAll('tr:not(#' + tableId + '-no-items-row)').length : 0;
            
            if (itemCount === 0) {
                e.preventDefault();
                const warning = document.getElementById('no-items-warning');
                if (warning) warning.style.display = 'block';
                alert('Please add at least one option before saving the template.');
                return false;
            }
        }
        
        if (createForm) {
            createForm.addEventListener('submit', validateForm);
        }
        
        if (editForm) {
            editForm.addEventListener('submit', validateForm);
        }
    })();
</script>
